#pragma once
#include <string>

// Generated from trimesh_shape.glsl on 2015-01-11
namespace scry {
namespace shader {
static const std::string kTrimeshShapeShader =
"#version 330 core\n#define __SHADER_NAME__\nuniform mat4 iModelViewMatrix;uniform mat4 iProjectionMatrix;uniform mat4 iModelViewProjectionMatrix;uniform mat3 iVectorModelViewMatrix;struct Light {bool IsEnabled;vec3 Color;vec3 Position; float ConstantAttenuation;float LinearAttenuation;float QuadraticAttenuation;};uniform vec3 iAmbient;uniform int iNumLights;uniform vec3 iEyeDirection;uniform float iShininess;uniform float iStrength;const int NumMaxLights = 20;uniform Light iLights[NumMaxLights];\n#ifdef VERTEX_SHADER\nlayout(location = 0) in vec3 VertexPosition;layout(location = 1) in vec3 VertexNormal;layout(location = 2) in vec4 VertexColor;layout(location = 3) in vec2 VertexTexCoord;out VS_GS_VERTEX {vec3 normal;vec4 color;} vertex_out;void main() {vertex_out.color = VertexColor;vertex_out.normal = VertexNormal;gl_Position = vec4(VertexPosition, 1);}\n#endif\n#ifdef GEOMETRY_SHADER\nlayout(triangles) in;layout(triangle_strip, max_vertices=3) out;in VS_GS_VERTEX {vec3 normal;vec4 color;} vertex_in[];out GS_FS_VERTEX {vec4 position;vec4 color;vec3 normal;vec3 d;} vertex_out;void main() {vec4 mid[3];mid[0] = (gl_in[1].gl_Position+gl_in[2].gl_Position)/2.0;mid[1] = (gl_in[2].gl_Position+gl_in[0].gl_Position)/2.0;mid[2] = (gl_in[0].gl_Position+gl_in[1].gl_Position)/2.0;for (int i = 0; i < gl_in.length(); i++) {vertex_out.position = gl_in[i].gl_Position;vertex_out.normal = vertex_in[i].normal;vertex_out.color = vertex_in[i].color;vertex_out.d[(i+1)%3] = vertex_out.d[(i+2)%3] = 0;vec3 v1 = gl_in[i].gl_Position.xyz;vec3 v2 = gl_in[(i+1)%3].gl_Position.xyz;vec3 v3 = gl_in[(i+2)%3].gl_Position.xyz;vec3 n = normalize(v3-v2);vec3 a = v2;vec3 p = v1;vertex_out.d[i] = length((a-p)-dot(a-p, n)*n);gl_Position = iModelViewProjectionMatrix * vertex_out.position;EmitVertex();}EndPrimitive();}\n#endif\n#ifdef FRAGMENT_SHADER\nin GS_FS_VERTEX {vec4 position;vec4 color;vec3 normal;vec3 d;} fragment_in;layout(location=0) out vec4 FragmentColor;void main() {vec3 normal = normalize(fragment_in.normal);vec4 col = vec4(iAmbient, fragment_in.color[3]);for (int i = 0; i < iNumLights; i++) {if (!iLights[i].IsEnabled) {continue;}vec3 light_dir = iLights[i].Position - vec3(fragment_in.position);float light_dist = length(light_dir);light_dir = light_dir / light_dist;float lambertian = max(dot(light_dir, fragment_in.normal), 0.0);float specular = 0.0;float attenuation = 1.0 /(iLights[i].ConstantAttenuation +(iLights[i].LinearAttenuation * light_dist) +(iLights[i].QuadraticAttenuation * light_dist * light_dist));if(lambertian > 0.0) {vec3 half_dir = normalize(light_dir + iEyeDirection);float spec_angle = max(dot(half_dir, fragment_in.normal), 0.0);specular = pow(spec_angle, iShininess) * iStrength;}col += vec4(lambertian * vec3(fragment_in.color) * attenuation +specular * mix(iLights[i].Color, vec3(fragment_in.color), 0.65) * attenuation, 0.0);}float edge_dist = min(min(fragment_in.d[0], fragment_in.d[1]), fragment_in.d[2])/0.001;float edge_intensity = pow(4, -pow(edge_dist, 2));vec4 edge_col = vec4(0, 0, 0, 0);FragmentColor = mix(col, edge_col, edge_intensity);}\n#endif";
}
}