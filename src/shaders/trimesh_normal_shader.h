#pragma once
#include <string>

// Generated from trimesh_normal.glsl on 2015-01-13
namespace librender {
namespace shader {
static const std::string kTrimeshNormalShader =
"#version 330 core\n#define __SHADER_NAME__\nuniform mat4 iProjectionMatrix;uniform mat4 iModelViewMatrix;uniform mat4 iModelViewProjectionMatrix;uniform mat3 iVectorModelViewMatrix;uniform vec4 iFaceNormalColor;uniform float iFaceNormalLength;\n#ifdef VERTEX_SHADER\nlayout(location = 0) in vec3 VertexPosition;layout(location = 1) in vec3 VertexNormal;layout(location = 2) in vec4 VertexColor;layout(location = 3) in vec2 VertexTexCoord;void main() {gl_Position = vec4(VertexPosition, 1);}\n#endif\n#ifdef GEOMETRY_SHADER\nconst int kNumArrowHeadVertices = 200;layout(triangles) in;layout(line_strip, max_vertices=202) out;out GS_FS_VERTEX {vec4 color;} vertex_out;mat4 RotationMatrix(vec3 axis, float angle) {axis = normalize(axis);float s = sin(angle);float c = cos(angle);float oc = 1.0 - c;return mat4(oc * axis.x * axis.x + c,oc * axis.x * axis.y - axis.z * s,oc * axis.z * axis.x + axis.y * s, 0.0,oc * axis.x * axis.y + axis.z * s,oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s, 0.0,oc * axis.z * axis.x - axis.y * s,oc * axis.y * axis.z + axis.x * s,oc * axis.z * axis.z + c, 0.0,0.0, 0.0, 0.0, 1.0);}void main() {vec3 face_normal = normalize(cross(gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz,gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz));vec4 face_center = vec4((gl_in[0].gl_Position.xyz +gl_in[1].gl_Position.xyz +gl_in[2].gl_Position.xyz) / 3.0, 1.0);gl_Position = iModelViewProjectionMatrix * face_center;vertex_out.color = iFaceNormalColor;EmitVertex();vec4 tip = (face_center + iFaceNormalLength * vec4(face_normal, 0));gl_Position = iModelViewProjectionMatrix * tip;EmitVertex();vec4 v = tip-face_center;mat4 rot = RotationMatrix(v.xyz, 3.1415/(kNumArrowHeadVertices/4)); const float arrow_head_width = 0.001;vec4 p = vec4(normalize(vec3(-1/v.x, -1/v.y, 2/v.z))*arrow_head_width, 1);for (int i=0; i<kNumArrowHeadVertices/2; ++i){gl_Position = iModelViewProjectionMatrix * tip;EmitVertex();vec4 d = vec4(face_center.xyz+v.xyz*0.65 + p.xyz, 1);gl_Position = iModelViewProjectionMatrix * d;EmitVertex();EndPrimitive();p = rot*p;}}\n#endif\n#ifdef FRAGMENT_SHADER\nin GS_FS_VERTEX {vec4 color;} fragment_in;layout(location=0) out vec4 FragmentColor;void main() {FragmentColor = fragment_in.color;}\n#endif";
}
}